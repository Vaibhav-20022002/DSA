// We are given two strings, ‘TEXT' and ‘S’. We have to calculate the no. of subsequences of ‘TEXT’, which are equal to ‘S’. Since the
// answer can be very large print it modulo (10^9)+7.
// A Subsequence of a string is the string that is generated by deleting 0 or more letters from the string and keeping the rest of the
// letters in the same order.

#include <iostream>
#include <vector>
using namespace std;
// TC -> O(exp) => REDUCING AND STAYING ON THE INDEXES WHILE MATCHING AND NON-MATCHING
// SC -> O(n + m) => MAXIMUM AUXILIARY STACK SPACE OF SUM OF BOTH STRING SIZES
// int countSubsequence(int i, int j, string &s1, string &s2)
// {
//     // BASE CASE :
//     // IF THE MATCHING STRING s2 GETS EXHAUSTED, RETURN 1 :
//     if (j < 0)
//         return 1;
//     // IF THE STRING s1 GETS EXAUSTED, RETURN 0 :
//     if (i < 0)
//         return 0;

//     // IF THE CHARACTERS MATCHES:
//     if (s1[i] == s2[j])
//         // IF TAKING BOTH THE MATCHING CHARACTERS + IF NOT TAKING THE MATCHING CHARACTERS
//         return (countSubsequence(i - 1, j - 1, s1, s2) + countSubsequence(i - 1, j, s1, s2));

//     // ELSE
//     return countSubsequence(i - 1, j, s1, s2);
// }

// MEMOIZATION:
// TC -> O(n * m)
// SC -> O(n + m) + O(n * m) => AUXILIARY STACK SPACE + DP MATRIX
// int countSubsequence(int i, int j, string &s1, string &s2, vector<vector<int>> &dp)
// {
//     // BASE CASE :
//     // IF THE MATCHING STRING s2 GETS EXHAUSTED, RETURN 1 :
//     if (j < 0)
//         return 1;
//     // IF THE STRING s1 GETS EXAUSTED, RETURN 0 :
//     if (i < 0)
//         return 0;

//     // IF THE PARTICULAR RECURSION CALL FOR <i, j> IS PRECOMPUTED, RETURN THE STORED VALUE:
//     if (dp[i][j] != -1)
//         return dp[i][j];
//     // IF THE CHARACTERS MATCHES:
//     if (s1[i] == s2[j])
//         // IF TAKING BOTH THE MATCHING CHARACTERS + IF NOT TAKING THE MATCHING CHARACTERS
//         return dp[i][j] = (countSubsequence(i - 1, j - 1, s1, s2, dp) + countSubsequence(i - 1, j, s1, s2, dp));

//     // ELSE
//     return dp[i][j] = countSubsequence(i - 1, j, s1, s2, dp);
// }

// TABULATION:
// TC -> O(n * m)
// SC -> O(n * m) => TABULATION MATRIX
// int countSubsequence(int n, int m, string &s1, string &s2)
// {
//     // SHIFTING THE ORIGIN:
//     // CREATING A TABULATION MATRIX:
//     vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));

//     // BASE CASE:
//     // IF jth INDEX IS ZERO:
//     for (int i = 0; i <= n; ++i)
//         dp[i][0] = 1;
//     // NOT REQUIRED, AS ALL ENTRIES ARE ALREADY ZERO !!!
//     // IF ith INDEX IS ZERO:
//     // for (int j = 0; j <= m; ++j)
//     //     dp[0][j] = 0;

//     for (int i = 1; i <= n; ++i)
//     {
//         for (int j = 1; j <= m; ++j)
//         {
//             if (s1[i - 1] == s2[j - 1])
//                 dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]);
//             else
//                 dp[i][j] = dp[i - 1][j];
//         }
//     }

//     // RETURN THE LAST COMPUTED INDEX:
//     return dp[n][m];
// }

// SPACE OPTIMIZATION:
int countSubsequence(int n, int m, string &s1, string &s2)
{
    // CREATING A 1-D VECTOR FOR STORING PREVIOUS ROW:
    vector<int> prev(m + 1, 0);

    // BASE CASE :
    prev[0] = 1;

    for (int i = 1; i <= n; ++i)
    {
        for (int j = m; j > 0; --j)
        {
            if (s1[i - 1] == s2[j - 1])
                // IF TAKING BOTH THE MATCHING CHARACTERS + IF NOT TAKING THE MATCHING CHARACTERS
                prev[j] = (prev[j - 1] + prev[j]);
        }
    }
    // RETURNING THE LAST COMPUTED CELL:
    return prev[m];
}
int main(void)
{
    string s1 = "brootgroot";
    string s2 = "brt";
    int n = s1.size();
    int m = s2.size();

    // RECURSION:
    // cout << countSubsequence(n - 1, m - 1, s1, s2);

    // MEMOIZATION:
    // vector<vector<int>> dp(n, vector<int>(m, -1));
    // cout << countSubsequence(n - 1, m - 1, s1, s2, dp);

    // TABULATION:
    // cout << countSubsequence(n, m, s1, s2);

    // SPACE OPTIMIZATION:
    cout << countSubsequence(n, m, s1, s2);
    return 0;
}